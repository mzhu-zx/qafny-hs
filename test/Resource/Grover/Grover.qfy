predicate Balanced(f : nat --> nat, n : nat)
  requires forall i :: 0 <= i < Pow2(n) :: f.requires(i)
  requires forall a | f.requires(a) :: f(a) == 0 || f(a) == 1
{
  var m := multiset(seq())
}

// Technically, this is a stricter version of 'f'.


method Grovers(q : Q[n], n:nat, f : nat -> nat, m:nat, N : nat) returns (y:nat, p : real)
  requires m < Pow2(n)
  require f.requires 
  requires forall k :: 0 <= k < m ==> f(k) == 1
  requires forall k :: m <= k < Pow2(n) ==> f(k) 0

  requires { q[0 , n) : Nor ↦ |0⟩ }
  //we should have a way of only specifying basis.
  //but we also care about amplitudes here.
  ensures N == pi / 4 * sqrt(2^n) ==>  p == 1
  ensures f(n2b(y)) == 1
{
  q[0, n) *= H;
  
  //q is splitted into the representation of two sets of |k⟩ based on f(k) == 1 and f(k) == 0.
  //in this mode, one cannot manipulate |k⟩, applying an oracle will do phase-kickback.
  //sin theta is computed by collecting all amplitudes for basis f(k) == 1, and cos theta is otherwise.
  //so in Grover's search, we have sin theta = sqrt(m/2^n) and cos theta = sqrt(N-m/2^n) 
  assert { q[0 .. n] : En ↦ forall k ∈ [0, 2^n) . (sin theta : f(k) == 1, cos theta : f(k) == 0) . |k⟩ }

  for i in [0, N)
    invariant {
      q[0 .. n] : En ↦ forall k ∈ [0, 2^n) . (sin (2 * i * theta + theta) : f(k) == 1, cos (2 * i * theta + theta) : f(k) == 0) . |k⟩ 
    }
  {
    //quantum mod-mult requires gcd(base,N) == 1 to implement, otherwise, it is not implementable.
    q[0, n) *= λ (y:Q n => f(y)); //this performs phase kick-back. only allowed operation (read from f and f is a function answers yes or no).
    q[0, n) *= amp; //apply amplitude amplification. Basically for any q as (sin var, cos var) |k⟩, applying amp to it is the following
                   // (sine (2 * theta) cos var - cos (2 * theta) sin var, cos (2*theta) cos var + sin (2 * theta) sin var)
                   //the theta is realted to the sin/cos structures the system formed.
                   //the first phase kick-back term will mark the f(k) == 1 terms, so that the amp will be useful.
                   //the phase kick-back is the so-called reflection.
  }

  y,p *= measure(q);
  // we can see that after a fixed number N interation, the chance p of measuring out q which is a key in f(y) == 1 is sin (2*N * theta + theta).
  // the chance of it to close to 1 will be to make 2*N*theta + theta == pi / 2.
  // so N will be roughly pi / (4*theta) - 1/2, theta can be estimated to be sqrt(m/2^n). N will be N == pi / 4 * sqrt(2^n)
}  

