// Amplitude estimation and counting
// https://arxiv.org/pdf/quant-ph/0005055.pdf

// Uf: Oracle function
//M: performs "phase-kickback".
//M: p and r are not actually entangled
method {:axiom} uf(p: Q[n], r: Q[1], n: nat)
  ensures { p[0, n), r[0] : En ↦ ∑ k ∈ [0, Pow2(n)) . 1 / sqrt(2^n) . -| k , 0 ⟩ }  //M: negative in front represents rotation of pi in complex plane, or -1 = e^(pi*i)=cos(pi)+i*sin(pi)

method qstep(p: Q[n], r: Q[1], n: nat, t: nat)
  // constrain the q-bits + natural number
  requires t <= Pow2(n)
  requires { p[0, n), r[0] : En ↦ ∑ k ∈ [0, Pow2(n)) . 1 / sqrt(2^n) . | k, 0 ⟩ } // registers should be in super position + entangled
  ensures { p[0, n) : Had ↦ ⊗ i ∈ [0, n) . |p[k]⟩ }
{
  for j in [0, t)
    invariant { p[0, n) : Had ↦ ⊗ i ∈ [0, n) . |p[k]⟩ }
  {
    uf(p, r, n);
    p[0, n) *= H;
    if p[0, n) == 0 then { r[0] *= r[0] + 1; } //L: reflection
    p[0, n) *= H;
  }
}

method AmplitudeEstimate(q: Q[n], r: Q[1], p: Q[n], n: nat) returns (y: nat, prob: real)
  requires { p[0 , n) : Nor ↦ |0⟩ }
  requires { r[0] : Nor ↦ |0⟩ }
  requires { q[0 , n) : Nor ↦ |0⟩ } //L: unsure about notation
  ensures prob >= 8 / pi^2
{
  // induce superposition on the 2 q-bits
  p[0, n) *= H;
  q[0, n) *= H;

  //L: is this valid in Dafny?
  //L: have to find a way to prove termination
  for j in [0, n) && q[j] //M: q[j] is the control for qstep for each j in [0, n). When this happens they become entangled.
    invariant { p[0, n) : Had ↦ ⊗ i ∈ [0, n) . |p[k]⟩ }
  {
    qstep(p, r, n, 2^j);
  }

  q[0, n) *= RQFT; //M: inverse fourier transform on q because q is now entangled with p
  y, prob := meas(q); //M: measure q to get the value and amplitude of that value
}