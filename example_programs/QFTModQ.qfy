// QFT mod Q
// https://people.eecs.berkeley.edu/~vazirani/s09quantum/notes/lecture6.pdf
// Section 0.3

method QFTModQ(q : Q[n], p : Q[n], n:nat, U : [Bool] -> [Bool], lambda : [Bool], Q:nat) returns (y:nat, p : real)
  requires forall k :: 0 <= k < 2^(n-1) ==> f(n2b(k)) == f(s xor n2b(k+2^n))
  requires b2n(s) != 0
    // we can assume that all elements in the function are lined up with, without losing generality, since we do not rely on the structure
  //requires { q[0 , n) : Nor ↦ |0⟩ }
  requires { p[0 , n) : Nor ↦ |0⟩ }
  //we should have a way of only specifying basis.
  //but we also care about amplitudes here.
  //ensures n2b(y) . s == 0 ==>  p == 0
  //ensures n2b(y) . s == 1 ==> p == 1 / 2^(n-1)
{
  p[0, n) *= H;

  // controlled phase shift
  p[0, n) *= CPhaseGate(q[0, n));

  q[0,n) *= RQFT;

  for i in [0, n) with q[i]
    separates q[0, i), p[0, n)
    invariant {
      q[0, i), p[0, n) : En ↦ ∑ k ∈ [0, 2^i)) . 1 / sqrt(2^n) . | k , f(k, p[k]) ⟩
    }
    invariant {
      q [i , n) : Had ↦ |+⟩
    }
  {
    //quantum mod-mult requires gcd(base,N) == 1 to implement, otherwise, it is not implementable.
    p[0, n) *= λ ((x: Q n, y:Q n) => (x, ((y + f(x)))));

    // This is super hacky, but I have no good way to do this now....
    // TODO: find out one way to take the reference of the underlying range
    // e.g. [[ p[0 .. N] ]] ?
    //#LemmaPowEquiv(p_seq'nat'_7__emit, base, i, N);
  }

  q[0, n) *= H;
  
  y,p *= measure(q);

}