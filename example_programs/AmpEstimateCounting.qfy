// Amplitude estimation and counting
// https://arxiv.org/pdf/quant-ph/0005055.pdf

method {:axiom} uf(q: Q[n], r: Q[1], n:nat)
    ensure { p[0,n),r[0] : EN ↦ ∑ k ∈ [0, Pow2(n)) . (-| k , 0 ⟩, | k , 0 ⟩) }
    
method qstep(p: Q[n], r:Q[1], n:nat, m:nat, t:nat)
{
  for j in [0,t)
  {
       uf(p,r);
       p[0,n) *= RAQFT(m);
       if p[0,n) == 0 then {r[0] *= r[0] + 1;} //reflection
       p[0,n) *= AQFT(m);   
  }
}

method AmplitudeEstimate(q : Q[n], r : Q[1], p : Q[n], m:nat, n:nat) returns (y: nat, prob: real)
    requires { p[0 , n) : Nor ↦ |0⟩ }
    requires { r[0] : Nor ↦ |0⟩ }
    requires { q[0 , n) : Nor ↦ A|0⟩ } // unsure about notation
{   
    p[0,n) *= H;
    q[0,n) *= AQFT(m);

    // is this valid in Dafny?
    // have to find a way to prove termination
    for j in [0,n) && q[j]
    {
      qstep(p,r,n,m,2^j);
    }
    
    q[0,m) *= RQFT;
    y,prob := meas(q);
}

method AppxCounting(m:nat, n:nat, epsilon: real) returns (a: nat)
{   

    var l := 0;
    var t := 0;
    
    while (t == 0 && 2^l < 2 * sqrt(m))
    {
       l := l + 1; 
       var q[0,n) *= init(n);
       var p[0,n) *= init(n);
       var r[0] *= init(1);
       var y,prob := AmplitudeEstimate(q,r,p,2^l,n);
       t := 2^l * y;
    }

    var M := ceiling(20*pi^2 * epsilon / 2^l);
    var q[0,n) *= init(n);
    var p[0,n) *= init(n);
    var r[0] *= init(1);
    var y,prob := AmplitudeEstimate(q,r,p,M,n);
    t := M * y;
    a = ceiling(t);
}



