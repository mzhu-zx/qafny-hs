#+TITLE: Proposal: Fused Conditional Merge
#+OPTIONS: toc:nil date:nil H:4 author:nil

* Synopsis

Currently the body of a conditional statement in the following manner

1. Gather all partitions related to the loop invariant
2. Resolve the guarded partition
3. Split the partition involving the guarded partition into two: one half
   contains the sub-/states/ that validates the guard and the other falsifies
   the guard.
4. Run compilation on two halves (in total twice) and skip emitting application
   statements for the false branch.
5. Discard duplicated yet non-entangled partitons and merge those entangled
   ones.
6. Do some house cleaning work ....

Following this approach, we can account for changes made by type cast and state
split under a unified semantics. However, a subtle nuisance is that the works on
non-entangled partitions are duplicated, because of which the solver could
have trouble in crushing VCs.

Informally, 
#+begin_src racket
  (define (compile `(for guard body))
    (merge
     (compile (filter-guard #t body))
     (skip-apply (compile (filter-guard #f body)))))
#+end_src

* Proposal

In order to avoid duplicated work, I propose an approach that compiles the body
in one pass (instead of two) and performs the split and merge process in each
=:*​=:= instead. This also requires tracing guarded partition through the
compilation of the body.

** Implementation Perspectives

Implementation-wise, the bookkeeping can be either done by argumenting current
=EmitState= in =TState= so that each =RBinding= points to the emitted variables
tagged with the guard expression/condition that indicates in which case the
each variable will be used.  

This enables an optimization we can exploit.

Currently, I implement the most general strategy in handling =for= statements by
splitting the guarded partition into exactly two parts and merging them in the
end because there could be a change in the number of kets under some interesting
operations. This also requires the knowledge on the accurate index to be used
for the state split.

With the new implementation, since we lift the split-and-merge to each
application statement, we can use a =Map=-based and index-agnostic
split-and-merge if the application statement guarantees that no new terms will
be introduced here, which is guaranteed by general λ functions.

Informally, 
#+begin_src racket
   (define (compile `(for guard body))
     (with-guarded-partitions guard
       (lift/statements compile body)))
#+end_src

** Wrinkles
This approach leaves the semantics of nested =if= or nested =for= loop
uninterpreted. An seemingly elegant solution is to wrap those =if= and =for=
statements into methods following the [[file:method.org][Method Calling Convention]].
#
For each method call in a conditional body, again duplicate the partition into
halves and perform the split and type cast based on the method signature for the
false branch.
