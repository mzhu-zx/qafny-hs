* Some Typing Related Notes

we first have a simple decision procedure
assume that the subrange function takes in a triple of list of predicates
Bound = Num | Var + Num 
each list in the triple is a list of (Bound,Bound)
the first means Bound = Bound, second means Bound <= Bound and the third means Bound < Bound
we first have a function to check the validity of the predicates

checkValid p = checks the validity of p. Output is either p is valid/not-valid or None (meaning that no enough info).
algorithm : for p = (l1,l2,l3), we first use l1 to generate substitutions, and then substitute l2 and l3. 
then, for each variable x, we check its circlarity in l2 to see if there is an bound x + n <= x + m,
if so, we can check n <= m, otherwise, the formula is not valid.
for l3 we check if x + n < x + m. 

genP : for an exp, based on predicate p, we gen predicates to make the exp + p is valid.
the exp can be x + n < y, x + n = y, and x + n <= y, where x and y are C vars, and n is an int.
for any exp, we can gen a bound pair, and check if p has the bound pair already, 
if so, not need to add to p, otherwise, the result is add the new bound pair with p.

the following is to cut a range into two ranges in a for-loop.
observation1: only for-loop requires a range cut (or user-defined range-cut-op, but let's workout for-loop first).
observation2: only three types of quantum-bools are allowed: x[i], u = v @ x[i], u < v @ x[i]
in the first kind, x is Q, i is C; second/third kind: u is Q and it is a range u[0,n) (n could be C), x is Q, v is C, i is C.
x and u must be variable only. while i could be bounds, and v could be C-kind exp, 
observation3: in all these three kinds, the range cut only applies on x[i] part, and it has no relation with u = v or u < v part.
for u part, we require that the u[0,n) the range stored in tenv must appear in the input session.
for example, if a session is {u[0,s),x[0,m)}, then s must equal to n. let's say that they are syntactic equal now.
so function rangeCut x[i], [a,b), (y[c,d)) finds i places in [c,d), where i is given in the range [a,b),
x and y are two Q var and i,a,b,c,d are bounds. qnum(x) = m, qnum(y) = s
the output is a Maybe, None --> cut is not valid. Just ([c,i),[i,d), p), 
where p is a new predicate set including the predicates to make the cut to be true.
[c,i),[i,d) is the two range cut results, and it is always [c,i), and [i,d)
first, x must equal to y. this is a check, if not, then None, meaning that the rangeCut is no meaning.
then 0 <= c <= a < b <= d is the predicates we need to generate. We do not allow the case when b > d.
Another predicate is that a <= i < b, which should be included in the input predicates.

We now deal with stmt "if x[i] (or u = v @ x[i], u < v @ x[i]) then e", we do not need to cut ranges, but to validRange
In a session having x, we know that x[c,d) is in the session, let's say that x has [0,n) in tenv.
First, notice that in e, it must not have any mention of i. this can be a type check. 
Second, i must be in [c,d) range. In this case, c might be arbitary bounds,
but we can generate predicate 0 <= c <= i < d < n
we can also allow users to set up increasing and decreasing flags.
increasing means that in e, any mention of x[j], j must be greater than i
decreasing means that in e, any mention of x[j], j must be less than i
if these two are set, then the range x[c,d) can then change, 
for increasing, other than the predicate 0 <= c <= i < d < n, we also have x[i+1,d) range inside e,
and once the if is finished, x[i,d) is recovered to x[c,d)
for increasing, other than the predicate 0 <= c <= i < d < n, we also have x[c,i) range inside e,
and once the if is finished, x[c,i) is recovered to x[c,d)

* Range SMT 

--------------------------------------------------------------------------------
-- | Range SMT 
--------------------------------------------------------------------------------
we first have a simple decision procedure
assume that the subrange function takes in a triple of list of predicates
Bound = Num | Var + Num 
each list in the triple is a list of (Bound,Bound)
the first means Bound = Bound, second means Bound <= Bound and the third means Bound < Bound
we first have a function to check the validity of the predicates

checkValid p = checks the validity of p. Output is either p is valid/not-valid or None (meaning that no enough info).
algorithm : for p = (l1,l2,l3), we first use l1 to generate substitutions, and then substitute l2 and l3. 
then, for each variable x, we check its circlarity in l2 to see if there is an bound x + n <= x + m,
if so, we can check n <= m, otherwise, the formula is not valid.
for l3 we check if x + n < x + m. 

genP : for an exp, based on predicate p, we gen predicates to make the exp + p is valid.
the exp can be x + n < y, x + n = y, and x + n <= y, where x and y are C vars, and n is an int.
for any exp, we can gen a bound pair, and check if p has the bound pair already, 
if so, not need to add to p, otherwise, the result is add the new bound pair with p.

the following is to cut a range into two ranges in a for-loop.
observation1: only for-loop requires a range cut (or user-defined range-cut-op, but let's workout for-loop first).
observation2: only three types of quantum-bools are allowed: x[i], u = v @ x[i], u < v @ x[i]
in the first kind, x is Q, i is C; second/third kind: u is Q and it is a range u[0,n) (n could be C), x is Q, v is C, i is C.
x and u must be variable only. while i could be bounds, and v could be C-kind exp, 
observation3: in all these three kinds, the range cut only applies on x[i] part, and it has no relation with u = v or u < v part.
for u part, we require that the u[0,n) the range stored in tenv must appear in the input session.
for example, if a session is {u[0,s),x[0,m)}, then s must equal to n. let's say that they are syntactic equal now.
so function rangeCut x[i], [a,b), (y[c,d)) finds i places in [c,d), where i is given in the range [a,b),
x and y are two Q var and i,a,b,c,d are bounds. qnum(x) = m, qnum(y) = s
the output is a Maybe, None --> cut is not valid. Just ([c,i),[i,d), p), 
where p is a new predicate set including the predicates to make the cut to be true.
[c,i),[i,d) is the two range cut results, and it is always [c,i), and [i,d)
first, x must equal to y. this is a check, if not, then None, meaning that the rangeCut is no meaning.
then 0 <= c <= a < b <= d is the predicates we need to generate. We do not allow the case when b > d.
Another predicate is that a <= i < b, which should be included in the input predicates.

We now deal with stmt "if x[i] (or u = v @ x[i], u < v @ x[i]) then e", we do not need to cut ranges, but to validRange
In a session having x, we know that x[c,d) is in the session, let's say that x has [0,n) in tenv.
First, notice that in e, it must not have any mention of i. this can be a type check. 
Second, i must be in [c,d) range. In this case, c might be arbitary bounds,
but we can generate predicate 0 <= c <= i < d < n
we can also allow users to set up increasing and decreasing flags.
increasing means that in e, any mention of x[j], j must be greater than i
decreasing means that in e, any mention of x[j], j must be less than i
if these two are set, then the range x[c,d) can then change, 
for increasing, other than the predicate 0 <= c <= i < d < n, we also have x[i+1,d) range inside e,
and once the if is finished, x[i,d) is recovered to x[c,d)
for increasing, other than the predicate 0 <= c <= i < d < n, we also have x[c,i) range inside e,
and once the if is finished, x[c,i) is recovered to x[c,d)


